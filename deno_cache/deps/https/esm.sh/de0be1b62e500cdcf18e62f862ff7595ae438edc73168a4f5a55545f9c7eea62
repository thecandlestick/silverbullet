/* esm.sh - esbuild bundle(y-protocols@1.0.5/awareness) deno production */
import*as d from"/v119/lib0@0.2.74/X-ZS95anM/deno/encoding.js";import*as l from"/v119/lib0@0.2.74/X-ZS95anM/deno/decoding.js";import*as m from"/v119/lib0@0.2.74/X-ZS95anM/deno/time.js";import*as y from"/v119/lib0@0.2.74/X-ZS95anM/deno/math.js";import{Observable as v}from"/v119/lib0@0.2.74/X-ZS95anM/deno/observable.js";import*as S from"/v119/lib0@0.2.74/X-ZS95anM/deno/function.js";import"yjs";var U=3e4,V=class extends v{constructor(o){super(),this.doc=o,this.clientID=o.clientID,this.states=new Map,this.meta=new Map,this._checkInterval=setInterval(()=>{let e=m.getUnixTime();this.getLocalState()!==null&&U/2<=e-this.meta.get(this.clientID).lastUpdated&&this.setLocalState(this.getLocalState());let t=[];this.meta.forEach((s,n)=>{n!==this.clientID&&U<=e-s.lastUpdated&&this.states.has(n)&&t.push(n)}),t.length>0&&L(this,t,"timeout")},y.floor(U/10)),o.on("destroy",()=>{this.destroy()}),this.setLocalState({})}destroy(){this.emit("destroy",[this]),this.setLocalState(null),super.destroy(),clearInterval(this._checkInterval)}getLocalState(){return this.states.get(this.clientID)||null}setLocalState(o){let e=this.clientID,t=this.meta.get(e),s=t===void 0?0:t.clock+1,n=this.states.get(e);o===null?this.states.delete(e):this.states.set(e,o),this.meta.set(e,{clock:s,lastUpdated:m.getUnixTime()});let c=[],h=[],a=[],g=[];o===null?g.push(e):n==null?o!=null&&c.push(e):(h.push(e),S.equalityDeep(n,o)||a.push(e)),(c.length>0||a.length>0||g.length>0)&&this.emit("change",[{added:c,updated:a,removed:g},"local"]),this.emit("update",[{added:c,updated:h,removed:g},"local"])}setLocalStateField(o,e){let t=this.getLocalState();t!==null&&this.setLocalState({...t,[o]:e})}getStates(){return this.states}},L=(i,o,e)=>{let t=[];for(let s=0;s<o.length;s++){let n=o[s];if(i.states.has(n)){if(i.states.delete(n),n===i.clientID){let c=i.meta.get(n);i.meta.set(n,{clock:c.clock+1,lastUpdated:m.getUnixTime()})}t.push(n)}}t.length>0&&(i.emit("change",[{added:[],updated:[],removed:t},e]),i.emit("update",[{added:[],updated:[],removed:t},e]))},M=(i,o,e=i.states)=>{let t=o.length,s=d.createEncoder();d.writeVarUint(s,t);for(let n=0;n<t;n++){let c=o[n],h=e.get(c)||null,a=i.meta.get(c).clock;d.writeVarUint(s,c),d.writeVarUint(s,a),d.writeVarString(s,JSON.stringify(h))}return d.toUint8Array(s)},O=(i,o)=>{let e=l.createDecoder(i),t=d.createEncoder(),s=l.readVarUint(e);d.writeVarUint(t,s);for(let n=0;n<s;n++){let c=l.readVarUint(e),h=l.readVarUint(e),a=JSON.parse(l.readVarString(e)),g=o(a);d.writeVarUint(t,c),d.writeVarUint(t,h),d.writeVarString(t,JSON.stringify(g))}return d.toUint8Array(t)},T=(i,o,e)=>{let t=l.createDecoder(o),s=m.getUnixTime(),n=[],c=[],h=[],a=[],g=l.readVarUint(t);for(let D=0;D<g;D++){let r=l.readVarUint(t),u=l.readVarUint(t),p=JSON.parse(l.readVarString(t)),f=i.meta.get(r),k=i.states.get(r),I=f===void 0?0:f.clock;(I<u||I===u&&p===null&&i.states.has(r))&&(p===null?r===i.clientID&&i.getLocalState()!=null?u++:i.states.delete(r):i.states.set(r,p),i.meta.set(r,{clock:u,lastUpdated:s}),f===void 0&&p!==null?n.push(r):f!==void 0&&p===null?a.push(r):p!==null&&(S.equalityDeep(p,k)||h.push(r),c.push(r)))}(n.length>0||h.length>0||a.length>0)&&i.emit("change",[{added:n,updated:h,removed:a},e]),(n.length>0||c.length>0||a.length>0)&&i.emit("update",[{added:n,updated:c,removed:a},e])};export{V as Awareness,T as applyAwarenessUpdate,M as encodeAwarenessUpdate,O as modifyAwarenessUpdate,U as outdatedTimeout,L as removeAwarenessStates};
//# sourceMappingURL=awareness.js.map